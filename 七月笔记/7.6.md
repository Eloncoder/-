# 目录
## makefile
> 自动化变量  
> 目标文件搜索  
> 隐含规则

## C++
> 预处理

# makefile
## 自动化变量
在 Makefile 中描述规则时，依赖文件和目标文件是**变动**的，显然在命令中不能出现具体的文件名称，否则模式规则将失去意义。
|自动化变量|	说明|
|:----:|:----:|
|$@|	表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 `.a` 文件为文档文件，也成为静态的库文件），那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。|
|$%	|当目标文件是一个静态库文件时，代表静态库的一个成员名。|
|$<	|规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。|
|$?	|所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（`.o` 文件）。|
|$^|	代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（`.o` 文件）名。一个文件可重复的出现在目标的依赖中，变量`$^`只记录它的第一次引用的情况。就是说变量`$^`会去掉重复的依赖文件。|
|$+	|类似`$^`，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。|
|$*	|在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中`%`所代表的部分（当文件名中存在目录时，“茎”也包含目录部分）。|

实例1：
```
test:test.o test1.o test2.o
         gcc -o $@ $^
test.o:test.c test.h
         gcc -o $@ $<
test1.o:test1.c test1.h
         gcc -o $@ $<
test2.o:test2.c test2.h
         gcc -o $@ $<
```
这个规则模式中用到了 `$@` 、`$<` 和 `$^` 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现 `$@` 代表的是目标文件test，`$^`代表的是依赖的文件，`$<`代表的是依赖文件中的第一个。
我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。
![1657074521(1)](https://user-images.githubusercontent.com/63440757/177454936-8c53a2f0-e1f0-4861-b00e-c8859a0d52fd.png)

实例2：
```
lib:test.o test1.o test2.o
    ar r $?
```
假如我们要做一个库文件，库文件的制作依赖于这三个文件。当修改了其中的某个依赖文件，在命令行执行 make 命令，库文件 `lib` 就会自动更新。`$?` 表示修改的文件。

## 目标文件搜索（VPATH和vpath）
VPATH 和 vpath 的区别：VPATH 是变量，更具体的说是环境变量，Makefile 中的一种特殊变量，使用时需要指定文件的路径；  
vpath 是关键字，按照模式搜索，也可以说成是选择搜索。搜索的时候不仅需要加上文件的路径，还需要加上相应限制的条件。
### VPATH的使用
在 Makefile 中可以这样写：
```
VPATH := src
```
我们可以这样理解，把 src 的值赋值给变量 VPATH，所以在执行 make 的时候会从 src 目录下找我们需要的文件。

当存在多个路径的时候我们可以这样写：
```
VPATH := src car
```
或者是
```
VPATH := src:car
```
多个路径之间要使用空格或者是冒号隔开，表示在多个路径下搜索文件。搜索的顺序为我们书写时的顺序，拿上面的例子来说，我们应该先搜索 src 目录下的文件，再搜索 car 目录下的文件。
注意：无论你定义了多少路径，make 执行的时候会先搜索当前路径下的文件，当前目录下没有我们要找的文件，才去 VPATH 的路径中去寻找。如果当前目录下有我们要使用的文件，那么 make 就会使用我们当前目录下的文件。

实例：
```
VPATH=src car
test:test.o
    gcc -o $@ $^
```
假设 test.c 文件没有在当前的目录而在当前文件的子目录 "src" 或者是 "car" 下，程序执行是没有问题的，但是生成的 test 的文件没有在定义的子目录文件中而是在当前的目录下，当然生成文件路径可以指定。
### vpath的使用
学习了 VPATH的使用，我们再来了解一下关键字搜索 vpath 的使用，这种搜索方式一般被称作选择性搜索。
使用上的区别我们可以这样理解：VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。
 
具体用法：
1) vpath PATTERN DIRECTORIES 
2) vpath PATTERN
3) vpath
4) 搜索的条件中可以包含模式字符`%`

( PATTERN：可以理解为要寻找的条件，DIRECTORIES：寻找的路径 )

首先是用法一，命令格式如下：
```
vpath test.c src
```
可以这样理解，在 src 路径下搜索文件 `test.c`。多路径的书写规则如下：
`vpath test.c src car`         
或者是
`vpath test.c src : car`

多路径的用法其实和 VPATH 差不多，都是使用空格或者是冒号分隔开，搜索路径的顺序是先 src 目录，然后是 car 目录。

其次是用法二，命令格式如下：
```
vpath test.c
```
用法二的意思是清除符合文件 test.c 的搜索目录。

最后是用法三，命令格式如下：
```
vpath
```
vpath 单独使的意思是清除所有已被设置的文件搜索路径。

## 隐含规则
实例：
```
test:test.o
    gcc -o test test.o
test.o:test.c
```
我们可以在 Makefile 中这样写来编译 `test.c` 源文件，相比较之前少写了重建 `test.o` 的命令。但是执行 make，发现依然重建了 `test` 和 `test.o` 文件，运行结果却没有改变。这其实就是隐含规则的作用。  
在某些时候其实不需要给出重建目标文件的命令，有的甚至可以不需要给出规则。  
实例：
```
test:test.o
    gcc -o test test.o
```
运行的结果是相同的。
> 注意：隐含条件只能省略中间目标文件重建的命令和规则，但是最终目标的命令和规则不能省略。

其实在有些时候隐含规则的使用会出现问题。因为有一个 make 的“隐含规则库”。库中的每一条隐含规则都有相应的优先级顺序，优先级也就会越高，使用时也就会被优先使用。

例如在 Makefile 中添加这行代码：
`foo.o:foo.p`

我们都知道 `.p` 文件是 `Pascal` 程序的源文件，如果书写规则时不加入命令的话，那么 make 会按照隐含的规则来重建目标文件 `foo.o`。如果当前目录下恰好存在 `foo.c` 文件的时候，隐含规则会把 `foo.c` 当做是 `foo.o` 的依赖文件进行目标文件的重建。因为编译 `.c` 文件的隐含规则在编译 `.p` 文件**之前**，显然**优先级也会越高**。
当 make 找到生成 `foo.o` 的文件之后，就不会再去寻找下一条规则。如果我们不想使用隐含规则，在使用的时候不仅要声明规则，也要添加上执行的命令。

内嵌隐含规则的命令中，所使用的变量都是预定义的。我们将这些变量称为“隐含变量”。这些变量允许修改。  
比如我们编译 `.c` 文件在我们的 Makefile 中就是隐含的规则，默认使用到的编译命令时`cc`，执行的命令时`cc -c`我们可以对用上面的任何一种方式将`CC`定义为`ncc`。这样我们就编译 `.c` 文件的时候就可以用`ncc`进行编译。

隐含规则中使用的变量可以分成两类：
1. 代表一个程序的名字。例如：“CC”代表了编译器的这个可执行程序。
2. 代表执行这个程序使用的参数.例如：变量“CFLAGS”。多个参数之间使用空格隔开。

下面我们来列举一下代表命令的变量，默认都是小写。
AR：函数库打包程序，可创建静态库 `.a` 文档。
AS：应用于汇编程序。
CC：C 编译程序。
CXX：C++编译程序。

## C++
### 预处理命令
C语言源文件要经过编译、链接才能生成可执行程序：  
1) 编译（Compile）会将源文件（`.c`文件）转换为目标文件。对于 VC/VS，目标文件后缀为`.obj`；对于GCC，目标文件后缀为`.o`。  
> 编译是针对单个源文件的，一次编译操作只能编译一个源文件，如果程序中有多个源文件，就需要多次编译操作。
2) 链接（Link）是针对多个文件的，它会将编译生成的多个目标文件以及系统中的库、组件等合并成一个可执行程序。  

预处理主要是处理以`#`开头的命令，编译器会将预处理的结果保存到和源文件同名的`.i`文件中。  
例如 `main.c` 的预处理结果在 `main.i` 中。和`.c`一样，`.i`也是文本文件，可以用编辑器打开直接查看内容。

`#include` 的用法有两种，如下所示：
```
#include <stdHeader.h>
#include "myHeader.h"
```
使用尖括号`< >`和双引号`" "`的区别在于头文件的搜索路径不同：  
使用尖括号`< >`，编译器会到系统路径下查找头文件；  
而使用双引号`" "`，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。  

**也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。**
```
#include "stdio.h"
#include "stdlib.h"
```
`stdio.h` 和 `stdlib.h` 都是标准头文件，它们存放于系统路径下，所以使用尖括号和双引号都能够成功引入；  
而我们**自己编写的头文件**，一般存放于**当前项目的路径**下，所以不能使用尖括号，只能使用**双引号**。

**需要注意的是，在宏定义中表达式`(n*n+3*n)`两边的括号不能少，否则在宏展开以后可能会产生歧义。**
```
#include <stdio.h>
#define SQ(y) (y)*(y)
int main(){
    int a,sq;
    printf("input a number: ");
    scanf("%d", &a);
    sq = 200 / SQ(a+1);
    printf("sq=%d\n", sq);
    return 0;
}
```
运行程序后，如果输入 9，那么我们希望的结果为 2。但实际情况并非如此：
```
input a number: 9
sq=200
```
为什么会得这样的结果呢？分析宏调用语句，在宏展开之后变为：
`sq=200/(a+1)*(a+1);`
`a` 为 9 时，由于“/”和“*”运算符优先级和结合性相同，所以先计算 `200/(9+1)`，结果为 20，再计算 `20*(9+1)`，最后得到 200。

为了得到正确答案，应该在宏定义中的整个字符串外加括号：
```
#include <stdio.h>
#define SQ(y) ((y)*(y))
int main(){
    int a,sq;
    printf("input a number: ");
    scanf("%d", &a);
    sq = 200 / SQ(a+1);
    printf("sq=%d\n", sq);
    return 0;
}
```
由此可见，对于带参宏定义不仅要在参数两侧加括号，还应该在**整个字符串外加括号**。

宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用`#undef`命令。例如：
```
#define PI 3.14159
int main(){
    // Code
    return 0;
}
#undef PI
void func(){
    // Code
}
```
表示 `PI` 只在 `main()` 函数中有效，在 `func()` 中无效。

代码中的宏名如果被**引号**包围，那么预处理程序不对其作宏代替，例如：
```
#include <stdio.h>
#define OK 100
int main(){
    printf("OK\n");
    return 0;
}
```
运行结果：
`OK`

该例中定义宏名 `OK` 表示 100，但在 printf 语句中 `OK` 被引号括起来，因此不作宏替换，而作为**字符串**处理。

可用宏定义表示数据类型，使书写方便。例如：
`#define UINT unsigned int`
在程序中可用 `UINT` 作变量说明：
`UINT a, b;`

应注意用宏定义表示数据类型和用 `typedef` 定义数据说明符的区别。
**宏定义**只是简单的**字符串替换**，由**预处理器**来处理；  
而 `typedef` 是在**编译阶段**由**编译器**处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。

请看下面的例子：
```
#define PIN1 int *
typedef int *PIN2;  //也可以写作typedef int (*PIN2);
```
从形式上看这两者相似， 但在实际使用中却不相同。

下面用 `PIN1`，`PIN2` 说明变量时就可以看出它们的区别：
`PIN1 a, b;`
在宏代换后变成：
`int * a, b;`
表示 `a` 是指向整型的指针变量，而 `b` 是整型变量。然而：
`PIN2 a,b;`
表示 `a`、`b` 都是指向整型的指针变量。因为 `PIN2` 是一个新的、完整的数据类型。  
由这个例子可见，**宏定义**虽然也可表示数据类型， 但毕竟只是**简单的字符串替换**。**在使用时要格外小心，以避出错。**

### 带参宏
```
#define M(y) y*y+3*y  //宏定义
// TODO:
k=M(5);  //宏调用
```
在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型。

这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。

带参数的宏和函数很相似，但有本质上的区别：  
宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。  
而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。  

### 条件编译
```
#include <stdio.h>
int main(){
    #if _WIN32
        system("color 0c");
        printf("http://c.biancheng.net\n");
    #elif __linux__
        printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
    #else
        printf("http://c.biancheng.net\n");
    #endif
    return 0;
}
```

对于 Windows 平台，预处理以后的代码变成：
```
#include <stdio.h>
#include <windows.h>
int main() {
    Sleep(5000);
    puts("http://c.biancheng.net/");
    return 0;
}
```
对于 Linux 平台，预处理以后的代码变成：
```
#include <stdio.h>
#include <unistd.h>
int main() {
    sleep(5);
    puts("http://c.biancheng.net/");
    return 0;
}
```
这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。

**这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译**。条件编译是预处理程序的功能，不是编译器的功能。

#if 的用法
```
#if 用法的一般格式为：
#if 整型常量表达式1
    程序段1
#elif 整型常量表达式2
    程序段2
#elif 整型常量表达式3
    程序段3
#else
    程序段4
#endif
```
`#if` 命令要求判断条件为**整型常量表达式**，也就是说，表达式中不能包含变量，而且结果必须是整数；

#ifdef 的用法
```
#ifdef  宏名
    程序段1
#else
    程序段2
#endif
```
它的意思是，如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。

> VS/VC 有两种编译模式，`Debug` 和 `Release`。在学习过程中，我们通常使用 `Debug` 模式，这样便于程序的调试；
> 而最终发布的程序，要使用 `Release` 模式，这样编译器会进行很多优化，提高程序运行效率，删除冗余信息。

为了能够清楚地看到当前程序的编译模式，我们不妨在程序中增加提示，请看下面的代码：
```
#include <stdio.h>
#include <stdlib.h>
int main(){
    #ifdef _DEBUG
        printf("正在使用 Debug 模式编译程序...\n");
    #else
        printf("正在使用 Release 模式编译程序...\n");
    #endif
    system("pause");
    return 0;
}
```
当以 `Debug` 模式编译程序时，宏 `_DEBUG` 会被定义，预处器会保留第 5 行代码，删除第 7 行代码。反之会删除第 5 行，保留第 7 行。

#ifndef 的用法
```
#ifndef 宏名
    程序段1 
#else 
    程序段2 
#endif
```
与 `#ifdef` 相比，仅仅是将 `#ifdef` 改为了 `#ifndef`。它的意思是，如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 `#ifdef` 的功能**正好相反**。

**三者之间的区别**
最后需要注意的是，`#if` 后面跟的是**整型常量表达式**，而 `#ifdef` 和 `#ifndef` 后面跟的只能是一个**宏名**，不能是其他的。

